## 手写常见js方法

> **1. 实现new方法**

```javascript
function objectCreate(Constructor, ...rest) {
  // 以构造函数的原型创建新对象
  var obj = Object.create(Constructor.prototype);
  // 以obj为this上下文来执行构造函数
  var res = Constructor.apply(obj, rest);
  // 根据new生成对象的原则,若有返回值为对象,则返回该结果,若没有,则返回开始生成的对象
  return typeof ret === 'object' ? res : obj
}

// 示例
function MyConstructor() {...}
var instance = objectCreate(MyConstructor, ...)
```

> **2.实现call方法**

```javascript
Function.prototype.myCall = function(context, ...args) {
  // 第一个参数为执行上下文,若为null则指向window
  var context = context || window;
  // this为执行的函数fn
  context.fn = this; 
  // 在context上下文中执行fn函数,并传入参数
  var result = context.fn(...args)
  delete context.fn
  return result
}
```

> **3. 实现apply方法**

```javascript
Function.prototype.myApply = function(context, args) {
  // 第一个参数为执行上下文,若为null则指向window
  var context = context || window;
  // this为执行的函数fn
  context.fn = this; 
  // 在context上下文中执行fn函数,并传入参数
  var result = context.fn(...args)
  delete context.fn
  return result
}
```

> **4.实现bind方法**

```javascript
Function.prototype.myBind = function(context, ...args1) {
  const _this = this
	var Func = function(...args2) {
    return _this.apply(this instanceOf Func ? this : context, args1.concat(args2))
  }
  Func.prototype = this.prototype
  return Func
} 
```

**注: `this instanceOf Func ? this : context`为了判断调用的方法是否为构造函数,如果是构造函数,则用new来调用, 此时上下文this不再是绑定的this,而是最后调用该函数的对象**